as.data.frame()
names <- rownames(df_coefs)
values <- df_coefs[, 1]
# Coefficients data frame clean
df_coefs <- df_coefs %>%
transmute(
feature = rownames(.),
value = `1`,
selected = value != 0
) %>%
# Non trivial features
filter(feature != '(Intercept)')
return(df_coefs)
}
bl <- bolasso(vs ~ mpg + disp + hp, mtcars, n_bootsraps = 10, family = 'binomial', threshold_selection = 0.5)
bl
mtcars$vs
bl
model <- bl
model$ridge_coefs
predictors
predictors_test <- mtcars[,c("mpg", "disp", "hp")]
predictors_test
predictors_test[, "(Intercept)"] <- 1
predictors_test
predictors_test[, model$ridge_coefs$feature]
predictors_test <- predictors_test[, model$ridge_coefs$feature]
as.matrix(predictors_test) %*% model$ridge_coefs$value
predictions <- as.matrix(predictors_test) %*% model$ridge_coefs$value
hardhat::spruce_numeric(predictions)
predictions <- as.vector(predictions)
predictions
hardhat::spruce_numeric(predictions)
log_odds <- predict_logistic_regression_link(model, predictors)
predict_logistic_regression_link <- function(model, predictors) {
# Rearrange to do matrix vector multiplication
predictors[, "(Intercept)"] <- 1
predictors <- predictors[, model$ridge_coefs$feature]
# Obtain predictions of linear model
predictions <- as.matrix(predictors_test) %*% model$ridge_coefs$value
predictions <- as.vector(predictions)
# Return in standard way
hardhat::spruce_numeric(predictions)
}
log_odds <- predict_logistic_regression_link(model, predictors)
predictors <- predictors_test
log_odds <- predict_logistic_regression_link(model, predictors)
log_odds
family <- stats::binomial()
# solve for p: `log_odds = ln(p / (1 - p))`
prob_success <- family$linkinv(log_odds)
# solve for p: `log_odds = ln(p / (1 - p))`
prob_success <- family$linkinv(log_odds$.pred)
prob_success
prob_failure <- 1 - prob_success
# Reverse the probabilities since `levels` will have failure first
prob <- cbind(prob_failure, prob_success)
blueprint <- model$blueprint
levels <- levels(blueprint$ptypes$outcomes[[1]])
levels
hardhat::spruce_prob(levels, prob)
blueprint$ptypes$outcomes[[1]]
prob
blueprint
blueprint <- model$blueprint
levels <- levels(blueprint$ptypes$outcomes[[1]])
hardhat::spruce_prob(levels, prob)
predictors <- as.matrix(mtcars[,c("mpg", "disp", "hp")])
outcome <- mtcars$vs
outcome <- as.factor(mtcars$vs)
bl <- bolasso(vs ~ mpg + disp + hp, mtcars, n_bootsraps = 10, family = 'binomial', threshold_selection = 0.5)
model <- bl
model$ridge_coefs
model$blueprint
model$blueprint$ptypes
prob
hardhat::spruce_numeric(predictions)
as_tibble(prob)
as_tibble(prob) %>%
rename(.prob0 = prob_failure, .prob1 = prob_success)
predict_bolasso_prob <- function(model, predictors) {
log_odds <- predict_logistic_regression_link(model, predictors)
family <- stats::binomial()
# solve for p: `log_odds = ln(p / (1 - p))`
prob_success <- family$linkinv(log_odds$.pred)
prob_failure <- 1 - prob_success
# Reverse the probabilities since `levels` will have failure first
prob <- cbind(prob_failure, prob_success)
as_tibble(prob) %>%
rename(.prob0 = prob_failure, .prob1 = prob_success)
# TODO: Improve this with blueprint
# blueprint <- model$blueprint
#
# levels <- levels(blueprint$ptypes$outcomes[[1]])
#
# hardhat::spruce_prob(levels, prob)
}
prob_tbl <- predict_logistic_regression_prob(model, predictors)
prob_tbl <- predict_bolasso_prob(model, predictors)
predictors <- predictors_test
prob_tbl <- predict_bolasso_prob(model, predictors)
prob_failure <- prob_tbl$.prob0
prob_failure
# Improve with blueprint
pred_class <- ifelse(prob_failure >= threshold_class, 1, 0)
threshold_class <- 0.6
# Improve with blueprint
pred_class <- ifelse(prob_failure >= threshold_class, 1, 0)
pred_class
hardhat::spruce_class(pred_class)
# Improve with blueprint
pred_class <- as.factor(ifelse(prob_failure >= threshold_class, 1, 0))
hardhat::spruce_class(pred_class)
predict_bolasso_numeric <- function(model, predictors) {
predict_bolasso_link(model, predictors)
}
predict_bolasso_prob <- function(model, predictors) {
log_odds <- predict_bolasso_link(model, predictors)
family <- stats::binomial()
# solve for p: `log_odds = ln(p / (1 - p))`
prob_success <- family$linkinv(log_odds$.pred)
prob_failure <- 1 - prob_success
# Reverse the probabilities since `levels` will have failure first
prob <- cbind(prob_failure, prob_success)
as_tibble(prob) %>%
rename(.prob0 = prob_failure, .prob1 = prob_success)
# TODO: Improve this with blueprint
# blueprint <- model$blueprint
#
# levels <- levels(blueprint$ptypes$outcomes[[1]])
#
# hardhat::spruce_prob(levels, prob)
}
predict_bolasso_class <- function(model, predictors, threshold_class) {
prob_tbl <- predict_bolasso_prob(model, predictors)
prob_failure <- prob_tbl$.prob0
# TODO: Improve with blueprint
pred_class <- as.factor(ifelse(prob_failure >= threshold_class, 1, 0))
hardhat::spruce_class(pred_class)
}
predict_bolasso_link <- function(model, predictors) {
# Rearrange to do matrix vector multiplication
predictors[, "(Intercept)"] <- 1
predictors <- predictors[, model$ridge_coefs$feature]
# Obtain predictions of linear model
predictions <- as.matrix(predictors_test) %*% model$ridge_coefs$value
predictions <- as.vector(predictions)
# Return in standard way
hardhat::spruce_numeric(predictions)
}
type <- 'prob'
get_predict_function <- function(type) {
switch(
type,
numeric = predict_bolasso_numeric,
link = predict_bolasso_link,
class = predict_bolasso_class,
prob = predict_bolasso_prob
)
}
predict_function <- get_predict_function(type)
predict_function
predictions <- predict_function(model, predictors)
hardhat::validate_prediction_size(predictions, predictors)
predictions
library(yardstick)
library(dplyr)
library(rsample)
library(tibble)
library(dplyr)
library(hardhat)
set.seed(123)
split <- initial_split(admittance)
split <- initial_split(mtcars)
train <- training(split)
test <- testing(split)
model <- bolasso(vs ~ mpg + disp + hp, mtcars, n_bootsraps = 10, family = 'binomial', threshold_selection = 0.5)
predict(model, test)
#' Predict from a `bolasso`
#'
#' @param object A `bolasso` object.
#'
#' @param new_data A data frame or matrix of new predictors.
#'
#' @param type A single character. The type of predictions to generate.
#' Valid options are:
#'
#' - `"numeric"` for numeric predictions.
#'
#' @param ... Not used, but required for extensibility.
#'
#' @return
#'
#' A tibble of predictions. The number of rows in the tibble is guaranteed
#' to be the same as the number of rows in `new_data`.
#'
#' @examples
#' train <- mtcars[1:20,]
#' test <- mtcars[21:32, -1]
#'
#' # Fit
#' mod <- bolasso(mpg ~ cyl + log(drat), train)
#'
#' # Predict, with preprocessing
#' predict(mod, test)
#'
#' @export
predict.bolasso <- function(object, new_data, type = "prob", ...) {
forged <- hardhat::forge(new_data, object$blueprint)
rlang::arg_match(type, valid_predict_types())
predict_bolasso_bridge(type, object, forged$predictors)
}
valid_predict_types <- function() {
c("numeric", "link", "prob", "class")
}
predict_bolasso_bridge <- function(type, model, predictors) {
predict_function <- get_predict_function(type)
predictions <- predict_function(model, predictors)
hardhat::validate_prediction_size(predictions, predictors)
predictions
}
get_predict_function <- function(type) {
switch(
type,
numeric = predict_bolasso_numeric,
link = predict_bolasso_link,
class = predict_bolasso_class,
prob = predict_bolasso_prob
)
}
predict_bolasso_numeric <- function(model, predictors) {
predict_bolasso_link(model, predictors)
}
predict_bolasso_prob <- function(model, predictors) {
log_odds <- predict_bolasso_link(model, predictors)
family <- stats::binomial()
# solve for p: `log_odds = ln(p / (1 - p))`
prob_success <- family$linkinv(log_odds$.pred)
prob_failure <- 1 - prob_success
# Reverse the probabilities since `levels` will have failure first
prob <- cbind(prob_failure, prob_success)
as_tibble(prob) %>%
rename(.prob0 = prob_failure, .prob1 = prob_success)
# TODO: Improve this with blueprint
# blueprint <- model$blueprint
#
# levels <- levels(blueprint$ptypes$outcomes[[1]])
#
# hardhat::spruce_prob(levels, prob)
}
predict_bolasso_class <- function(model, predictors, threshold_class) {
prob_tbl <- predict_bolasso_prob(model, predictors)
prob_failure <- prob_tbl$.prob0
# TODO: Improve with blueprint
pred_class <- as.factor(ifelse(prob_failure >= threshold_class, 1, 0))
hardhat::spruce_class(pred_class)
}
predict_bolasso_link <- function(model, predictors) {
# Rearrange to do matrix vector multiplication
predictors[, "(Intercept)"] <- 1
predictors <- predictors[, model$ridge_coefs$feature]
# Obtain predictions of linear model
predictions <- as.matrix(predictors_test) %*% model$ridge_coefs$value
predictions <- as.vector(predictions)
# Return in standard way
hardhat::spruce_numeric(predictions)
}
predict(model, test)
predict_bolasso_numeric <- function(model, predictors) {
predict_bolasso_link(model, predictors)
}
predict_bolasso_prob <- function(model, predictors) {
log_odds <- predict_bolasso_link(model, predictors)
family <- stats::binomial()
# solve for p: `log_odds = ln(p / (1 - p))`
prob_success <- family$linkinv(log_odds$.pred)
prob_failure <- 1 - prob_success
# Reverse the probabilities since `levels` will have failure first
prob <- cbind(prob_failure, prob_success)
as_tibble(prob) %>%
rename(.prob0 = prob_failure, .prob1 = prob_success)
# TODO: Improve this with blueprint
# blueprint <- model$blueprint
#
# levels <- levels(blueprint$ptypes$outcomes[[1]])
#
# hardhat::spruce_prob(levels, prob)
}
predict_bolasso_class <- function(model, predictors, threshold_class) {
prob_tbl <- predict_bolasso_prob(model, predictors)
prob_failure <- prob_tbl$.prob0
# TODO: Improve with blueprint
pred_class <- as.factor(ifelse(prob_failure >= threshold_class, 1, 0))
hardhat::spruce_class(pred_class)
}
predict_bolasso_link <- function(model, predictors) {
# Rearrange to do matrix vector multiplication
predictors[, "(Intercept)"] <- 1
predictors <- predictors[, model$ridge_coefs$feature]
# Obtain predictions of linear model
predictions <- as.matrix(predictors) %*% model$ridge_coefs$value
predictions <- as.vector(predictions)
# Return in standard way
hardhat::spruce_numeric(predictions)
}
predict(model, test)
predict(model, test, type = "class")
predict(model, test, type = "class", threshold_class = 0.5)
predict_bolasso_bridge <- function(type, model, predictors, ...) {
predict_function <- get_predict_function(type)
predictions <- predict_function(model, predictors, ...)
hardhat::validate_prediction_size(predictions, predictors)
predictions
}
get_predict_function <- function(type) {
switch(
type,
numeric = predict_bolasso_numeric,
link = predict_bolasso_link,
class = predict_bolasso_class,
prob = predict_bolasso_prob
)
}
#' Predict from a `bolasso`
#'
#' @param object A `bolasso` object.
#'
#' @param new_data A data frame or matrix of new predictors.
#'
#' @param type A single character. The type of predictions to generate.
#' Valid options are:
#'
#' - `"numeric"` for numeric predictions.
#'
#' @param ... Not used, but required for extensibility.
#'
#' @return
#'
#' A tibble of predictions. The number of rows in the tibble is guaranteed
#' to be the same as the number of rows in `new_data`.
#'
#' @examples
#' train <- mtcars[1:20,]
#' test <- mtcars[21:32, -1]
#'
#' # Fit
#' mod <- bolasso(mpg ~ cyl + log(drat), train)
#'
#' # Predict, with preprocessing
#' predict(mod, test)
#'
#' @export
predict.bolasso <- function(object, new_data, type = "prob", ...) {
forged <- hardhat::forge(new_data, object$blueprint)
rlang::arg_match(type, valid_predict_types())
predict_bolasso_bridge(type, object, forged$predictors, ...)
}
valid_predict_types <- function() {
c("numeric", "link", "prob", "class")
}
predict(model, test, type = "class", threshold_class = 0.5)
predict_bolasso_numeric <- function(model, predictors) {
predict_bolasso_link(model, predictors)
}
predict_bolasso_prob <- function(model, predictors) {
log_odds <- predict_bolasso_link(model, predictors)
family <- stats::binomial()
# solve for p: `log_odds = ln(p / (1 - p))`
prob_success <- family$linkinv(log_odds$.pred)
prob_failure <- 1 - prob_success
# Reverse the probabilities since `levels` will have failure first
prob <- cbind(prob_failure, prob_success)
as_tibble(prob) %>%
rename(.prob0 = prob_failure, .prob1 = prob_success)
# TODO: Improve this with blueprint
# blueprint <- model$blueprint
#
# levels <- levels(blueprint$ptypes$outcomes[[1]])
#
# hardhat::spruce_prob(levels, prob)
}
predict_bolasso_class <- function(model, predictors, threshold_class = 0.5) {
prob_tbl <- predict_bolasso_prob(model, predictors)
prob_failure <- prob_tbl$.prob0
# TODO: Improve with blueprint
pred_class <- as.factor(ifelse(prob_failure >= threshold_class, 1, 0))
hardhat::spruce_class(pred_class)
}
predict_bolasso_link <- function(model, predictors) {
# Rearrange to do matrix vector multiplication
predictors[, "(Intercept)"] <- 1
predictors <- predictors[, model$ridge_coefs$feature]
# Obtain predictions of linear model
predictions <- as.matrix(predictors) %*% model$ridge_coefs$value
predictions <- as.vector(predictions)
# Return in standard way
hardhat::spruce_numeric(predictions)
}
predict(model, test, type = "class")
predict(model, test, type = "class")
predict(model, test, type = "prob")
#' Fit bridge
#'
#' @details
#'
#' The bridge connects the high level interface methods with the low level
#' implementation.
#'
#' Pass through other objects to the implementation function as required.
#'
#' @param processed
#'
#' @keywords internal
bolasso_bridge <- function(processed, ...) {
# Predictors work: if not numeric, glmnet will crash
predictors <- processed$predictors
hardhat::validate_predictors_are_numeric(predictors)
# Outcome work
outcome <- processed$outcomes[[1]]
fit <- bolasso_impl(predictors, outcome, ...)
new_bolasso(
df_coefs = fit$df_coefs,
ridge_coefs = fit$ridge_coefs,
blueprint = processed$blueprint
)
}
split <- initial_split(mtcars)
train <- training(split)
test <- testing(split)
model <- bolasso(vs ~ mpg + disp + hp, mtcars, n_bootsraps = 10, family = 'binomial', threshold_selection = 0.5)
predict(model, test)
predict(model, test, type = "class")
predict(model, test, type = "prob")
train <- mtcars[1:20,]
test <- mtcars[21:32, -1]
# Fit
mod <- bolasso(mpg ~ cyl + log(drat), train)
# Predict, with preprocessing
predict(mod, test)
library(bolasso)
library(bolasso)
split <- initial_split(mtcars)
train <- training(split)
test <- testing(split)
model <- bolasso(vs ~ mpg + disp + hp, mtcars, n_bootsraps = 10, family = 'binomial', threshold_selection = 0.5)
predict(model, test)
predict(model, test, type = "class")
predict(model, test, type = "prob")
library(bolasso)
library(bolasso)
library(bolasso)
library(bolasso)
library(bolasso)
library(bolasso)
predictors <- mtcars[, -1]
outcome <- mtcars[, 1]
# XY interface
mod <- bolasso(predictors, outcome)
# Formula interface
mod2 <- bolasso(mpg ~ ., mtcars)
# Recipes interface
library(recipes)
rec <- recipe(mpg ~ ., mtcars)
rec <- step_log(rec, disp)
mod3 <- bolasso(rec, mtcars)
library(bolasso)
predictors <- mtcars[, -1]
outcome <- mtcars[, 1]
# XY interface
mod <- bolasso(predictors, outcome)
# Formula interface
mod2 <- bolasso(mpg ~ ., mtcars)
# Recipes interface
library(recipes)
rec <- recipe(mpg ~ ., mtcars)
rec <- step_log(rec, disp)
mod3 <- bolasso(rec, mtcars)
mtcars
predictors <- mtcars[,c("mpg", "disp", "hp")]
outcome <- mtcars[, c("vs")]
# XY interface
mod <- bolasso(predictors, outcome)
# Formula interface
mod2 <- bolasso(mpg ~ ., mtcars)
# Recipes interface
library(recipes)
rec <- recipe(mpg ~ ., mtcars)
rec <- step_log(rec, disp)
mod3 <- bolasso(rec, mtcars)
library(bolasso)
library(bolasso)
library(bolasso)
predictors <- mtcars[,c("mpg", "disp", "hp")]
outcome <- mtcars[, "vs"]
# XY interface
mod <- bolasso(predictors, outcome)
# Formula interface
mod2 <- bolasso(mpg ~ ., mtcars)
# Recipes interface
library(recipes)
rec <- recipe(mpg ~ ., mtcars)
rec <- step_log(rec, disp)
mod3 <- bolasso(rec, mtcars)
mod2 <- bolasso(vs ~ ., mtcars)
library(bolasso)
train <- mtcars[1:20,]
test <- mtcars[21:32, -1]
# Fit
mod <- bolasso(mpg ~ cyl + log(drat), train)
# Predict, with preprocessing
predict(mod, test)
library(bolasso)
